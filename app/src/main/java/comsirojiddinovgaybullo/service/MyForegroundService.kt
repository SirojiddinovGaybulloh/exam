package comsirojiddinovgaybullo.serviceimport android.app.Notificationimport android.app.NotificationChannelimport android.app.NotificationManagerimport android.app.Serviceimport android.content.ContentResolverimport android.content.Contextimport android.content.Intentimport android.icu.text.SimpleDateFormatimport android.media.AudioAttributesimport android.net.Uriimport android.os.Buildimport android.os.IBinderimport android.os.SystemClockimport android.text.format.DateFormatimport android.util.Logimport androidx.core.app.NotificationCompatimport androidx.core.app.NotificationManagerCompatimport comsirojiddinovgaybullo.exam.Rimport java.sql.Dateimport java.util.*class  MyForegroundService : Service() {    private lateinit var notification: Notification    private lateinit var thread: Thread    private val TAG = "MyBackgroundServiceTAG"    private var isStopped=false    override fun onBind(intent: Intent?): IBinder? {        return null    }    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {        Log.d(TAG, "onStartCommand: ${intent!!.getBooleanExtra("state", false)}")        if (intent.getBooleanExtra("state", false)) {           this.thread= Thread {                while (!isStopped) {                    Log.d(TAG, "onStartCommand: ")                    Thread.sleep(1_000)                }            }               thread.start()        }else{            stopSelf(notificationId)        }        createNotificationChannel()        createNotification()        startForeground(notificationId,notification)        return super.onStartCommand(intent, flags, startId)    }    private val CHANNEL_ID="channel1"    private fun createNotificationChannel() {        // Create the NotificationChannel, but only on API 26+ because        // the NotificationChannel class is new and not in the support library        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {            val name = "R.string.channel_name"            val descriptionText ="R.string.channel_description"            val importance = NotificationManager.IMPORTANCE_HIGH            val channel = NotificationChannel(CHANNEL_ID, name, importance).apply {                description = descriptionText            }            val uri= Uri.Builder()                .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)                .authority(packageName)                .appendPath("${R.raw.iphone}")                .build()            val audioAttributes= AudioAttributes.Builder()                .setUsage(AudioAttributes.USAGE_NOTIFICATION)                .build()            channel.setSound(uri,audioAttributes)            // Register the channel with the system            val notificationManager: NotificationManager =                getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager            notificationManager.createNotificationChannel(channel)            val date = Date()            val timeFormat: SimpleDateFormat = SimpleDateFormat("HH:mm:ss", Locale.getDefault())            val time: String = timeFormat.format(date)        }    }    private val notificationId=123    private fun createNotification() {        val progressMax = 100        this.notification = NotificationCompat.Builder(this, CHANNEL_ID)            .setSmallIcon(R.drawable.ic_launcher_foreground)            .setContentTitle("textTitle")            .setOngoing(true)            .setProgress(progressMax,0,true)            .setOnlyAlertOnce(true)            .setContentText("textContent")            .setPriority(NotificationCompat.PRIORITY_DEFAULT)            .setAutoCancel(true)            .build()        createNotificationChannel()        with(NotificationManagerCompat.from(this)) {            // notificationId is a unique int for each notification that you must define            notify(notificationId,notification)        }        Thread(Runnable {            SystemClock.sleep(2000)            var progress = 0            while (progress <= progressMax) {                SystemClock.sleep(                    1000                )                progress += 10                this.notification =                    NotificationCompat.Builder(this, CHANNEL_ID)                        .setSmallIcon(R.drawable.ic_round_done_24)                        .setContentText("$progress%")                        .setProgress(progressMax, progress, false)                        .build()                with(NotificationManagerCompat.from(this)) {                    notify(notificationId, notification)                }            }            this.notification =                NotificationCompat.Builder(this, CHANNEL_ID)                    .setSmallIcon(R.drawable.ic_round_done_24)                    .setContentText("Download completed")                    .build()            with(NotificationManagerCompat.from(this)) {                notify(notificationId, notification)            }        }).start()    }    override fun onDestroy() {        Log.d(TAG, "onDestroy: ")        isStopped=true        super.onDestroy()    }}